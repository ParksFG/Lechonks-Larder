export function isPromise(value) {
    return (typeof value === 'object' &&
        value !== null &&
        typeof value.then === 'function');
}
function observableToPromise(observable) {
    return new Promise((resolve, reject) => {
        const subscription = observable.subscribe({
            next: v => {
                resolve(v);
                subscription.unsubscribe();
            },
            error: reject,
            complete: () => {
                reject(new Error('no value resolved'));
            },
        });
    });
}
export function isObservable(value) {
    return (typeof value === 'object' &&
        value !== null &&
        'subscribe' in value &&
        typeof value.subscribe === 'function');
}
export function isAsyncIterable(input) {
    return (typeof input === 'object' &&
        input !== null &&
        (input[Symbol.toStringTag] === 'AsyncGenerator' ||
            Symbol.asyncIterator in input));
}
function asyncIterableToPromise(input) {
    return new Promise((resolve, reject) => {
        var _a;
        const iteratorReturn = (_a = ('return' in input ? input : input[Symbol.asyncIterator]()).return) === null || _a === void 0 ? void 0 : _a.bind(input);
        const iteratorNext = ('next' in input ? input : input[Symbol.asyncIterator]()).next.bind(input);
        iteratorNext()
            .then(result => {
            resolve(result.value);
            iteratorReturn === null || iteratorReturn === void 0 ? void 0 : iteratorReturn();
        })
            .catch(err => {
            reject(err);
        });
    });
}
export function fetcherReturnToPromise(fetcherResult) {
    return Promise.resolve(fetcherResult).then(result => {
        if (isAsyncIterable(result)) {
            return asyncIterableToPromise(result);
        }
        else if (isObservable(result)) {
            return observableToPromise(result);
        }
        return result;
    });
}
//# sourceMappingURL=index.js.map